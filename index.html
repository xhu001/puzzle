 <!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>拼圖直邊檢測 - OpenCV.js</title>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>

<style>
  body { margin:0; padding:12px; font-family:-apple-system,sans-serif; background:#000; color:#eee; }
  h2 { text-align:center; margin:0.6em 0; }
  #container { display:flex; flex-direction:column; align-items:center; }
  video, canvas { max-width:100%; border:2px solid #333; border-radius:10px; background:#111; }
  .btn { margin:10px 8px; padding:12px 28px; font-size:17px; border:none; border-radius:8px; background:#0066ff; color:white; }
  .btn:active { background:#0050cc; }
  #status { margin:12px 0; padding:8px; background:rgba(0,0,0,0.5); border-radius:8px; min-height:1.4em; }
</style>
</head>
<body>

<div id="container">
  <h2>檢測有直邊的拼圖塊（邊緣件）</h2>
  
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas" style="display:none"></canvas>
  <canvas id="output"></canvas>
  
  <div>
    <button class="btn" id="startBtn">開啟後置攝影機</button>
    <button class="btn" id="captureBtn">拍照</button>
    <button class="btn" id="detectBtn" disabled>檢測直邊</button>
  </div>
  
  <div id="status">等待 OpenCV.js 載入...</div>
</div>

<script>
// ================================================
let cvReady = false;
let video, canvas, ctx, outputCanvas, outCtx;
let stream = null;

const STATUS = document.getElementById('status');

// 主要參數（可依實際拼圖大小調整）
const MIN_AREA_RATIO   = 0.0007;
const MAX_AREA_RATIO   = 0.03;
const ASPECT_TOLERANCE = 0.35;
const APPROX_EPSILON   = 0.018;     // 全輪廓逼近精度
const SIDE_APPROX_EPS  = 0.035;     // 每邊單獨逼近的精度（較寬鬆）
const MIN_SIDE_POINTS  = 60;        // 單邊至少要有這麼多點才判斷

function onOpenCvReady() {
  cv['onRuntimeInitialized'] = () => {
    cvReady = true;
    STATUS.textContent = 'OpenCV.js 已載入完成～可以開始使用了';
    document.getElementById('detectBtn').disabled = false;
  };
}

window.onload = () => {
  video = document.getElementById('video');
  canvas = document.getElementById('canvas');
  ctx = canvas.getContext('2d');
  outputCanvas = document.getElementById('output');
  outCtx = outputCanvas.getContext('2d');

  document.getElementById('startBtn').onclick = startCamera;
  document.getElementById('captureBtn').onclick = capture;
  document.getElementById('detectBtn').onclick = detectStraightEdges;
};

async function startCamera() {
  if (!cvReady) return alert("OpenCV 還在載入，請稍候...");
  
  try {
    if (stream) stream.getTracks().forEach(t=>t.stop());
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment", width: {ideal:1280}, height:{ideal:960} }
    });
    video.srcObject = stream;
    STATUS.textContent = "攝影機已開啟 → 對準拼圖後按「拍照」";
  } catch(e) {
    STATUS.textContent = "無法開啟攝影機：" + e.message;
  }
}

function capture() {
  if (!stream) return alert("請先開啟攝影機");
  
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  outputCanvas.width = canvas.width;
  outputCanvas.height = canvas.height;

  ctx.drawImage(video, 0, 0);
  outCtx.drawImage(canvas, 0, 0);
 // 新增：縮小圖像到可處理範圍（保持比例）
  const MAX_WIDTH = 960;  // 或 800 / 1200 都可，視你的手機調整
  if (canvas.width > MAX_WIDTH) {
    const ratio = MAX_WIDTH / canvas.width;
    const newHeight = canvas.height * ratio;

    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = MAX_WIDTH;
    tempCanvas.height = newHeight;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(canvas, 0, 0, MAX_WIDTH, newHeight);

    // 覆蓋原 canvas
    canvas.width = MAX_WIDTH;
    canvas.height = newHeight;
    ctx.drawImage(tempCanvas, 0, 0);
  }

  // 同步設定 output
  outputCanvas.width = canvas.width;
  outputCanvas.height = canvas.height;
  outCtx.drawImage(canvas, 0, 0);
  STATUS.textContent = `已拍照！  ${canvas.width}×${canvas.height}`;
}

function detectStraightEdges() {
  if (!cvReady || canvas.width === 0) {
    STATUS.textContent = "請先拍照！";
    return;
  }

  STATUS.textContent = "正在分析直邊... (可能需要幾秒)";

  let src = cv.imread(canvas);
  let gray = new cv.Mat();
  let blurred = new cv.Mat();
  let thresh = new cv.Mat();

  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, blurred, new cv.Size(3,3), 0);
  cv.adaptiveThreshold(blurred, thresh, 255,
    cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 9, 3);

  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  // 先把原始拍照畫回去，準備標記
  outCtx.drawImage(canvas, 0, 0);

  let edgePieceCount = 0;

  for (let i = 0; i < contours.size(); ++i) {
    let cnt = contours.get(i);
    let area = cv.contourArea(cnt);
    if (area < 100) continue;

    let perimeter = cv.arcLength(cnt, true);
    let approx = new cv.Mat();
    cv.approxPolyDP(cnt, approx, APPROX_EPSILON * perimeter, true);

    if (approx.rows < 4) { approx.delete(); continue; }

    let rect = cv.boundingRect(cnt);
    let aspect = Math.abs(rect.width / rect.height - 1);
    let areaRatio = area / (src.rows * src.cols);

    if (areaRatio < MIN_AREA_RATIO || areaRatio > MAX_AREA_RATIO ||
        aspect > ASPECT_TOLERANCE) {
      approx.delete();
      continue;
    }

    // ── 重點：開始檢查是否有直邊 ─────────────────────────────
    let hasStraightEdge = false;
    let points = cnt.data32S; // int32 陣列 [x1,y1, x2,y2, ...]

    // 粗略分成四段（簡單平均分法，實際可改用角點檢測更精確）
    const n = points.length / 2;
    const segLen = Math.floor(n / 4);
    const segments = [
      {start: 0,           end: segLen},
      {start: segLen,      end: segLen*2},
      {start: segLen*2,    end: segLen*3},
      {start: segLen*3,    end: n}
    ];

    for (let seg of segments) {
      let segPoints = [];
      for (let j = seg.start; j < seg.end; j++) {
        segPoints.push([points[j*2], points[j*2+1]]);
      }
      // 最後一點連回第一點（閉合）
      segPoints.push(segPoints[0]);

      let segMat = cv.matFromArray(segPoints.length, 1, cv.CV_32SC2, [].concat(...segPoints));
      let segApprox = new cv.Mat();
      let segPeri = cv.arcLength(segMat, true);
      cv.approxPolyDP(segMat, segApprox, SIDE_APPROX_EPS * segPeri, true);

      // 如果逼近後只剩 2 個點 → 這段非常接近直線
      if (segApprox.rows <= 2 && segMat.rows > MIN_SIDE_POINTS) {
        hasStraightEdge = true;
      }

      segMat.delete();
      segApprox.delete();
    }

    // ── 畫框 ────────────────────────────────
    let color;
    if (hasStraightEdge) {
      // 有直邊 → 紅色 + 較粗
      color = new cv.Scalar(255, 80, 80, 220); // 紅
      edgePieceCount++;
      cv.rectangle(outCtx.canvas,
        {x:rect.x, y:rect.y},
        {x:rect.x+rect.width, y:rect.y+rect.height},
        color, Math.max(6, Math.round(canvas.width/280)));
    } else {
      // 普通塊 → 黃色細框
      color = new cv.Scalar(255, 255, 0, 180);
      cv.rectangle(outCtx.canvas,
        {x:rect.x, y:rect.y},
        {x:rect.x+rect.width, y:rect.y+rect.height},
        color, 3);
    }

    approx.delete();
  }

  // 清理
  src.delete(); gray.delete(); blurred.delete(); thresh.delete();
  contours.delete(); hierarchy.delete();

  STATUS.textContent = `分析完成！ 找到 ${edgePieceCount} 個疑似有直邊的邊緣塊（紅色標記）`;
}
</script>
</body>
</html>
