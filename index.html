<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>拼图检测 - OpenCV.js 版 (≈2×2cm方块)</title>

<!-- OpenCV.js 官方最新稳定版 (2025-2026 常用版本) -->
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>

<style>
  body {
    margin: 0;
    padding: 12px;
    font-family: -apple-system, BlinkMacOSystemFont, sans-serif;
    background: #000;
    color: #eee;
  }
  h2 { margin: 0.6em 0; text-align: center; }
  #container { display: flex; flex-direction: column; align-items: center; }
  video, canvas { 
    max-width: 100%; 
    border: 2px solid #333; 
    border-radius: 10px; 
    background: #111;
  }
  .btn {
    margin: 10px 8px;
    padding: 12px 28px;
    font-size: 17px;
    border: none;
    border-radius: 8px;
    background: #0066ff;
    color: white;
  }
  .btn:active { background: #0050cc; }
  #status {
    margin: 12px 0;
    padding: 8px;
    background: rgba(0,0,0,0.5);
    border-radius: 8px;
    min-height: 1.4em;
  }
</style>
</head>
<body>

<div id="container">
  <h2>拼图块检测 ≈2×2cm (OpenCV.js)</h2>
  
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas" style="display:none"></canvas>
  <canvas id="output"></canvas>
  
  <div>
    <button class="btn" id="startBtn">开启后置摄像头</button>
    <button class="btn" id="captureBtn">拍照</button>
    <button class="btn" id="detectBtn">检测方块</button>
  </div>
  
  <div id="status">等待 OpenCV.js 加载...</div>
</div>

<script>
// 全局变量
let cvReady = false;
let video, canvas, ctx, outputCanvas, outCtx;
let stream = null;

const STATUS = document.getElementById('status');

// 参数（针对 ≈2×2cm 方块，手机拍照常见分辨率）
const MIN_AREA_RATIO   = 0.0006;    // 最小面积占比
const MAX_AREA_RATIO   = 0.025;     // 最大面积占比（防大块噪声）
const ASPECT_TOLERANCE = 0.30;      // 长宽比偏离 1 的最大容忍（越小越严格）
const APPROX_EPSILON   = 0.022;     // 多边形逼近精度 (相对周长)
const MIN_CONTOUR_SIZE = 40;        // 轮廓点数下限，防噪声

function onOpenCvReady() {
  cv['onRuntimeInitialized'] = () => {
    cvReady = true;
    STATUS.textContent = 'OpenCV.js 已加载完成！可以开始使用了～';
    document.getElementById('detectBtn').disabled = false;
  };
}

// 初始化
window.onload = () => {
  video = document.getElementById('video');
  canvas = document.getElementById('canvas');
  ctx = canvas.getContext('2d');
  outputCanvas = document.getElementById('output');
  outCtx = outputCanvas.getContext('2d');

  document.getElementById('startBtn').onclick = startCamera;
  document.getElementById('captureBtn').onclick = capture;
  document.getElementById('detectBtn').onclick = detectSquares;
  document.getElementById('detectBtn').disabled = true;
};

async function startCamera() {
  if (!cvReady) {
    STATUS.textContent = "OpenCV.js 还在加载，请稍等...";
    return;
  }

  try {
    if (stream) stream.getTracks().forEach(t => t.stop());

    stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: "environment",
        width: { ideal: 1280 },
        height: { ideal: 960 }
      }
    });

    video.srcObject = stream;
    STATUS.textContent = "摄像头已开启 → 请对准拼图后按「拍照」";
  } catch (e) {
    STATUS.textContent = "摄像头开启失败: " + e.message;
  }
}

function capture() {
  if (!stream) {
    alert("请先开启摄像头");
    return;
  }

  // 设置 canvas 尺寸与视频一致
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  outputCanvas.width = canvas.width;
  outputCanvas.height = canvas.height;

  ctx.drawImage(video, 0, 0);
  outCtx.drawImage(canvas, 0, 0);

  STATUS.textContent = `已拍照！分辨率: ${canvas.width}×${canvas.height}`;
}

function detectSquares() {
  if (!cvReady) {
    STATUS.textContent = "OpenCV.js 尚未准备好...";
    return;
  }
  if (canvas.width === 0) {
    STATUS.textContent = "请先拍照！";
    return;
  }

  STATUS.textContent = "正在检测... (可能需要几秒)";

  // 1. 准备 OpenCV Mat
  let src = cv.imread(canvas);
  let gray = new cv.Mat();
  let blurred = new cv.Mat();
  let edges = new cv.Mat();
  let thresh = new cv.Mat();

  // 2. 预处理
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
  
  // 自适应阈值通常对拼图效果更好
  cv.adaptiveThreshold(blurred, thresh, 255,
    cv.ADAPTIVE_THRESH_GAUSSIAN_C,
    cv.THRESH_BINARY_INV, 11, 2);

  // 3. 找轮廓
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(thresh, contours, hierarchy,
    cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  // 4. 清空上一帧结果，只保留原始拍照图像
  outCtx.drawImage(canvas, 0, 0);

  let count = 0;

  // 5. 遍历所有轮廓，进行方块过滤
  for (let i = 0; i < contours.size(); ++i) {
    let cnt = contours.get(i);
    let area = cv.contourArea(cnt);

    if (area < 100) continue; // 太小直接跳过

    // 周长 → 用于相对精度逼近
    let perimeter = cv.arcLength(cnt, true);
    let approx = new cv.Mat();
    cv.approxPolyDP(cnt, approx, APPROX_EPSILON * perimeter, true);

    // 只保留近似四边形（四角形）
    if (approx.rows !== 4) {
      approx.delete();
      continue;
    }

    // 计算边界框
    let rect = cv.boundingRect(cnt);
    let aspectRatio = Math.abs(rect.width / rect.height - 1);

    let areaRatio = area / (src.rows * src.cols);

    // 核心过滤条件
    if (areaRatio < MIN_AREA_RATIO || areaRatio > MAX_AREA_RATIO) {
      approx.delete();
      continue;
    }
    if (aspectRatio > ASPECT_TOLERANCE) {
      approx.delete();
      continue;
    }

    // 画高亮框（黄色 + 粗线 + 半透明）
    let color = new cv.Scalar(255, 255, 0, 220); // 黄 + 透明度
    let thickness = Math.max(4, Math.round(canvas.width / 320)); // 自适应粗细

    cv.rectangle(outCtx.canvas, 
      {x: rect.x, y: rect.y},
      {x: rect.x + rect.width, y: rect.y + rect.height},
      color, thickness);

    // 可选：画中心点（红色小圆）
    // let centerX = rect.x + rect.width / 2;
    // let centerY = rect.y + rect.height / 2;
    // cv.circle(outCtx.canvas, {x:centerX, y:centerY}, 6, [255,0,0,255], -1);

    count++;
    approx.delete();
  }

  // 释放内存（非常重要！）
  src.delete(); gray.delete(); blurred.delete();
  edges.delete(); thresh.delete();
  contours.delete(); hierarchy.delete();

  STATUS.textContent = `检测完成！找到约 ${count} 个疑似 2×2cm 方块`;
}
</script>
</body>
</html>
