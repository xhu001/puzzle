<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>拍拼图 → 自动框出2cm方块</title>
<style>
  body {
    margin: 0;
    padding: 10px;
    font-family: -apple-system, BlinkMacOSystemFont, sans-serif;
    background: #000;
    color: #fff;
  }
  #container {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  video, canvas {
    max-width: 100%;
    border: 1px solid #444;
    border-radius: 8px;
    background: #111;
  }
  .btn {
    margin: 12px;
    padding: 12px 28px;
    font-size: 18px;
    border: none;
    border-radius: 8px;
    background: #0066ff;
    color: white;
    touch-action: manipulation;
  }
  .btn:active {
    background: #0050cc;
  }
  #status {
    margin: 10px 0;
    color: #0f9;
    font-size: 15px;
  }
</style>
</head>
<body>

<div id="container">
  <h2>拼图块检测（约2×2cm）</h2>
  
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas" style="display:none"></canvas>
  <canvas id="result" width="640" height="480"></canvas>
  
  <div>
    <button class="btn" id="btnStart">开启摄像头</button>
    <button class="btn" id="btnCapture">拍照</button>
    <button class="btn" id="btnDetect">检测并框出方块</button>
  </div>
  
  <div id="status">准备就绪...</div>
</div>

<script>
// ======================== 主要参数 ========================
const APPROX_SIZE_CM   = 2;           // 目标尺寸 ≈ 2cm
const MIN_AREA_FACTOR  = 0.0008;       // 最小面积占比（调小可检测更多小块）
const MAX_AREA_FACTOR  = 0.025;        // 最大面积占比
const ASPECT_TOL       = 0.35;         // 长宽比容忍度（越小越严格正方形）
const CONTOUR_PERIM_SCALE = 0.018;     // 近似多边形精度参数（越小越严格）

let video = document.getElementById('video');
let canvas = document.getElementById('canvas');
let ctx    = canvas.getContext('2d');
let resultCanvas = document.getElementById('result');
let rctx = resultCanvas.getContext('2d');

let stream = null;

// 1. 开启摄像头
document.getElementById('btnStart').onclick = async () => {
  try {
    if (stream) stream.getTracks().forEach(t => t.stop());
    
    stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: "environment", // 后置摄像头
        width: { ideal: 1280 },
        height: { ideal: 960 }
      }
    });
    
    video.srcObject = stream;
    document.getElementById('status').textContent = "摄像头已开启";
  } catch(e) {
    alert("无法打开摄像头\n" + e.message);
    document.getElementById('status').textContent = "摄像头开启失败";
  }
};

// 2. 拍照
document.getElementById('btnCapture').onclick = () => {
  if (!stream) {
    alert("请先开启摄像头");
    return;
  }
  
  // 根据视频实际尺寸设置 canvas
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  
  ctx.drawImage(video, 0, 0);
  document.getElementById('status').textContent = "已拍照！可进行检测";
};

// 3. 检测并画框（简单轮廓检测 + 过滤近似正方形）
document.getElementById('btnDetect').onclick = () => {
  if (canvas.width === 0) {
    alert("请先拍照");
    return;
  }

  const status = document.getElementById('status');
  status.textContent = "正在检测...";

  // 复制拍照的图像到结果画布
  resultCanvas.width = canvas.width;
  resultCanvas.height = canvas.height;
  rctx.drawImage(canvas, 0, 0);

  // 简易边缘检测（使用卷积算子）
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const gray = grayscale(imgData);
  const edges = sobel(gray, canvas.width, canvas.height);

  // 寻找轮廓（非常简易的4连通区域增长法）
  const contours = simpleContourDetection(edges, canvas.width, canvas.height);

  let count = 0;

  for (const contour of contours) {
    if (contour.length < 30) continue; // 太小不要

    // 计算边界框
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const p of contour) {
      minX = Math.min(minX, p.x);
      minY = Math.min(minY, p.y);
      maxX = Math.max(maxX, p.x);
      maxY = Math.max(maxY, p.y);
    }

    const w = maxX - minX + 1;
    const h = maxY - minY + 1;
    const area = w * h;
    const aspect = Math.abs(w / h - 1);

    const areaRatio = area / (canvas.width * canvas.height);

    // 面积 & 长宽比过滤（最关键的两条）
    if (areaRatio < MIN_AREA_FACTOR || areaRatio > MAX_AREA_FACTOR) continue;
    if (aspect > ASPECT_TOL) continue;

    // 画高亮边框（黄色半透明 + 粗线）
    rctx.strokeStyle = "rgba(255, 255, 0, 0.85)";
    rctx.lineWidth = 4;
    rctx.strokeRect(minX, minY, w, h);

    // 可选：画中心小十字，便于观察
    // rctx.fillStyle = "red";
    // rctx.fillRect(minX + w/2 - 4, minY + h/2 - 4, 8, 8);

    count++;
  }

  status.textContent = `检测完成！找到约 ${count} 个疑似 2cm 方块`;
};

// ===================== 辅助函数 =====================

// 转灰度
function grayscale(imgData) {
  const data = imgData.data;
  const out = new Uint8Array(imgData.width * imgData.height);
  for (let i = 0; i < data.length; i += 4) {
    const v = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
    out[i>>2] = v|0;
  }
  return out;
}

// 简易 Sobel 边缘检测（只返回强度）
function sobel(gray, w, h) {
  const out = new Uint8Array(w * h);
  for (let y = 1; y < h-1; y++) {
    for (let x = 1; x < w-1; x++) {
      const i = y*w + x;
      const gx = -gray[(y-1)*w + x-1] + gray[(y-1)*w + x+1]
               - 2*gray[ y*w    + x-1] + 2*gray[ y*w    + x+1]
               - gray[(y+1)*w + x-1] + gray[(y+1)*w + x+1];

      const gy = -gray[(y-1)*w + x-1] - 2*gray[(y-1)*w + x] - gray[(y-1)*w + x+1]
               +  gray[(y+1)*w + x-1] + 2*gray[(y+1)*w + x] + gray[(y+1)*w + x+1];

      const mag = Math.sqrt(gx*gx + gy*gy) | 0;
      out[i] = Math.min(255, mag);
    }
  }
  return out;
}

// 非常简易的轮廓提取（4连通 + 阈值）
function simpleContourDetection(edges, w, h) {
  const visited = new Uint8Array(w * h);
  const contours = [];

  for (let y = 1; y < h-1; y++) {
    for (let x = 1; x < w-1; x++) {
      const i = y*w + x;
      if (visited[i] || edges[i] < 80) continue; // 阈值可调

      const contour = [];
      const stack = [{x,y}];

      while (stack.length) {
        const p = stack.pop();
        const idx = p.y * w + p.x;
        if (visited[idx] || edges[idx] < 60) continue;

        visited[idx] = 1;
        contour.push(p);

        // 4连通
        if (p.x > 0)     stack.push({x:p.x-1, y:p.y});
        if (p.x < w-1)   stack.push({x:p.x+1, y:p.y});
        if (p.y > 0)     stack.push({x:p.x,   y:p.y-1});
        if (p.y < h-1)   stack.push({x:p.x,   y:p.y+1});
      }

      if (contour.length > 30) {
        contours.push(contour);
      }
    }
  }
  return contours;
}

</script>
</body>
</html>
