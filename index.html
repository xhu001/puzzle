<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
body { 
  margin: 0; 
  background: #000; 
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, sans-serif;
}
#container {
  position: relative;
  width: 100vw;
  height: 100vh;
}
button {
  position: fixed; 
  top: 20px; 
  left: 50%;
  transform: translateX(-50%);
  font-size: 18px; 
  padding: 12px 24px;
  z-index: 10;
  background: #007AFF;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}
button:active {
  background: #0051D5;
}
#controls {
  position: fixed;
  top: 80px;
  left: 10px;
  right: 10px;
  z-index: 10;
  display: none;
  max-height: 60vh;
  overflow-y: auto;
}
#controls.active {
  display: block;
}
.control-group {
  background: rgba(0,0,0,0.85);
  padding: 10px;
  margin-bottom: 5px;
  border-radius: 8px;
  color: white;
  font-size: 12px;
}
.control-group label {
  display: block;
  margin-bottom: 5px;
}
.control-group input[type="range"] {
  width: 100%;
}
.toggle-btn {
  background: #444;
  border: none;
  color: white;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 12px;
  margin-right: 5px;
  margin-top: 5px;
}
.toggle-btn.active {
  background: #007AFF;
}
#status {
  position: fixed;
  bottom: 20px;
  left: 10px;
  right: 10px;
  color: white;
  background: rgba(0,0,0,0.85);
  padding: 12px;
  border-radius: 8px;
  font-size: 13px;
  z-index: 10;
  line-height: 1.4;
}
canvas { 
  position: absolute; 
  top: 0; 
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
}
video { 
  display: none; 
}
</style>
</head>
<body>
<div id="container">
  <button id="start">启动摄像头</button>
  
  <div id="controls">
    <div class="control-group">
      <label>最小面积: <span id="minAreaVal">50</span>px²</label>
      <input type="range" id="minArea" min="20" max="500" value="50" step="10">
    </div>
    <div class="control-group">
      <label>最大面积: <span id="maxAreaVal">5000</span>px²</label>
      <input type="range" id="maxArea" min="500" max="20000" value="5000" step="500">
    </div>
    <div class="control-group">
      <label>边缘检测: <span id="cannyLowVal">20</span> / <span id="cannyHighVal">60</span></label>
      <input type="range" id="cannyLow" min="5" max="100" value="20" step="5">
      <input type="range" id="cannyHigh" min="30" max="200" value="60" step="10">
    </div>
    <div class="control-group">
      <label>
        <input type="checkbox" id="adaptiveThresh" checked> 使用自适应阈值
      </label>
    </div>
    <div class="control-group">
      显示模式:
      <button class="toggle-btn" data-mode="normal">仅边块</button>
      <button class="toggle-btn active" data-mode="all">所有拼图</button>
      <button class="toggle-btn" data-mode="edges">边缘图</button>
    </div>
  </div>
  
  <div id="status">等待 OpenCV 加载...</div>
  <video id="video" playsinline muted autoplay></video>
  <canvas id="canvas"></canvas>
</div>

<script>
let opencvReady = false;
let streaming = false;
let processingInterval = null;

// OpenCV Mats
let src, gray, edges, blurred, thresh;

// 参数
let params = {
  minArea: 50,
  maxArea: 5000,
  cannyLow: 20,
  cannyHigh: 60,
  displayMode: 'all',
  useAdaptive: true
};

const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d", { willReadFrequently: true });
const startBtn = document.getElementById("start");
const statusDiv = document.getElementById("status");
const controlsDiv = document.getElementById("controls");

// 控制参数
document.getElementById("minArea").oninput = function() {
  params.minArea = parseInt(this.value);
  document.getElementById("minAreaVal").textContent = this.value;
};

document.getElementById("maxArea").oninput = function() {
  params.maxArea = parseInt(this.value);
  document.getElementById("maxAreaVal").textContent = this.value;
};

document.getElementById("cannyLow").oninput = function() {
  params.cannyLow = parseInt(this.value);
  document.getElementById("cannyLowVal").textContent = this.value;
};

document.getElementById("cannyHigh").oninput = function() {
  params.cannyHigh = parseInt(this.value);
  document.getElementById("cannyHighVal").textContent = this.value;
};

document.getElementById("adaptiveThresh").onchange = function() {
  params.useAdaptive = this.checked;
};

// 显示模式切换
document.querySelectorAll('.toggle-btn').forEach(btn => {
  btn.onclick = function() {
    document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
    params.displayMode = this.dataset.mode;
  };
});

// 动态加载 OpenCV.js
function loadOpenCV() {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = 'https://docs.opencv.org/4.x/opencv.js';
    script.async = true;
    
    script.onload = () => {
      if (typeof cv !== 'undefined') {
        cv.onRuntimeInitialized = () => {
          opencvReady = true;
          statusDiv.textContent = 'OpenCV 已加载 - 点击按钮开始';
          resolve();
        };
      } else {
        reject(new Error('OpenCV 加载失败'));
      }
    };
    
    script.onerror = () => reject(new Error('OpenCV 脚本加载失败'));
    document.head.appendChild(script);
  });
}

// 启动摄像头
startBtn.onclick = async () => {
  if (!opencvReady) {
    statusDiv.textContent = '请等待 OpenCV 加载完成...';
    return;
  }
  
  try {
    statusDiv.textContent = '正在启动摄像头...';
    
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { 
        facingMode: "environment",
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    });
    
    video.srcObject = stream;
    video.onloadedmetadata = () => {
      video.play();
    };
    
    startBtn.style.display = 'none';
    controlsDiv.classList.add('active');
    
  } catch (e) {
    statusDiv.textContent = '摄像头错误: ' + e.message;
    alert("无法访问摄像头: " + e.message);
  }
};

// 视频开始播放
video.addEventListener("playing", () => {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  
  statusDiv.textContent = `初始化中 (${canvas.width}x${canvas.height})`;
  
  try {
    src = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC4);
    gray = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC1);
    edges = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC1);
    blurred = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC1);
    thresh = new cv.Mat(canvas.height, canvas.width, cv.CV_8UC1);
    
    streaming = true;
    
    if (processingInterval) clearInterval(processingInterval);
    processingInterval = setInterval(processFrame, 150);
    
  } catch (e) {
    statusDiv.textContent = '初始化错误: ' + e.message;
  }
});

function processFrame() {
  if (!streaming || !opencvReady) return;
  
  try {
    // 读取视频帧
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    cv.imread(canvas, src);
    
    // 转灰度
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    
    // 高斯模糊
    cv.GaussianBlur(gray, blurred, new cv.Size(3, 3), 0);
    
    // 使用自适应阈值或 Canny
    if (params.useAdaptive) {
      // 自适应阈值效果更好
      cv.adaptiveThreshold(blurred, thresh, 255, 
        cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 2);
      
      // 形态学操作清理噪声
      let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
      cv.morphologyEx(thresh, thresh, cv.MORPH_CLOSE, kernel);
      cv.morphologyEx(thresh, thresh, cv.MORPH_OPEN, kernel);
      kernel.delete();
      
      edges.delete();
      edges = thresh.clone();
    } else {
      // Canny 边缘检测
      cv.Canny(blurred, edges, params.cannyLow, params.cannyHigh);
    }
    
    // 显示边缘模式
    if (params.displayMode === 'edges') {
      cv.imshow(canvas, edges);
      statusDiv.textContent = '边缘检测视图 - 白色区域应包含拼图边界';
      return;
    }
    
    // 查找轮廓
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    
    // 重新绘制原图
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    let totalContours = contours.size();
    let validContours = 0;
    let straightEdgeCount = 0;
    
    // 分析所有轮廓
    let puzzlePieces = [];
    
    for (let i = 0; i < totalContours; i++) {
      let contour = contours.get(i);
      let area = cv.contourArea(contour);
      
      // 面积过滤 - 针对小拼图
      if (area < params.minArea || area > params.maxArea) {
        continue;
      }
      
      validContours++;
      
      // 分析形状
      let hasStraight = analyzeShape(contour, area);
      
      puzzlePieces.push({
        contour: contour,
        area: area,
        hasStraight: hasStraight
      });
    }
    
    // 绘制结果
    for (let piece of puzzlePieces) {
      if (params.displayMode === 'all') {
        // 显示所有拼图
        if (piece.hasStraight) {
          straightEdgeCount++;
          drawContour(piece.contour, 'rgba(0, 255, 0, 0.9)', 3);
          ctx.fillStyle = 'rgba(0, 255, 0, 0.25)';
        } else {
          drawContour(piece.contour, 'rgba(255, 165, 0, 0.8)', 2);
          ctx.fillStyle = 'rgba(255, 165, 0, 0.15)';
        }
        fillContour(piece.contour);
      } else if (params.displayMode === 'normal' && piece.hasStraight) {
        // 只显示边块
        straightEdgeCount++;
        drawContour(piece.contour, 'rgba(0, 255, 0, 0.9)', 3);
        ctx.fillStyle = 'rgba(0, 255, 0, 0.25)';
        fillContour(piece.contour);
      }
    }
    
    // 更新状态信息
    let statusText = `检测: ${totalContours}个轮廓 | 有效: ${validContours}个拼图`;
    statusText += `\n绿色=${straightEdgeCount}个边块 | 橙色=${validContours - straightEdgeCount}个内部块`;
    statusDiv.innerHTML = statusText.replace('\n', '<br>');
    
    contours.delete();
    hierarchy.delete();
    
  } catch (e) {
    console.error('处理错误:', e);
    statusDiv.textContent = '错误: ' + e.message;
  }
}

// 分析形状 - 针对小拼图优化
function analyzeShape(contour, area) {
  // 方法1: 多边形近似
  let approx = new cv.Mat();
  let perimeter = cv.arcLength(contour, true);
  cv.approxPolyDP(contour, approx, 0.02 * perimeter, true);
  
  let hasStraight = false;
  let vertices = approx.rows;
  
  // 拼图块通常有4-10个顶点
  if (vertices >= 3 && vertices <= 10) {
    // 检查边长
    for (let i = 0; i < vertices; i++) {
      let x1 = approx.data32S[i * 2];
      let y1 = approx.data32S[i * 2 + 1];
      let x2 = approx.data32S[((i + 1) % vertices) * 2];
      let y2 = approx.data32S[((i + 1) % vertices) * 2 + 1];
      
      let edgeLen = Math.hypot(x2 - x1, y2 - y1);
      
      // 如果有边长超过周长的10%
      if (edgeLen > perimeter * 0.1) {
        // 检查这条边是否足够直（相对于其他边）
        let avgEdgeLen = perimeter / vertices;
        if (edgeLen > avgEdgeLen * 1.2) {
          hasStraight = true;
          break;
        }
      }
    }
  }
  
  // 方法2: 矩形拟合
  if (!hasStraight) {
    let rect = cv.minAreaRect(contour);
    let boxArea = rect.size.width * rect.size.height;
    let extent = area / boxArea; // 填充度
    
    // 如果形状接近矩形（填充度高）
    if (extent > 0.7) {
      hasStraight = true;
    }
  }
  
  // 方法3: 凸包检测
  if (!hasStraight && vertices >= 4) {
    let hull = new cv.Mat();
    cv.convexHull(contour, hull);
    let hullArea = cv.contourArea(hull);
    let solidity = area / hullArea;
    
    // 如果凸度高（形状规整）
    if (solidity > 0.85 && vertices <= 6) {
      hasStraight = true;
    }
    hull.delete();
  }
  
  approx.delete();
  return hasStraight;
}

// 绘制轮廓
function drawContour(contour, color, width) {
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  
  for (let i = 0; i < contour.data32S.length; i += 2) {
    let x = contour.data32S[i];
    let y = contour.data32S[i + 1];
    
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
  }
  
  ctx.closePath();
  ctx.stroke();
}

// 填充轮廓
function fillContour(contour) {
  ctx.beginPath();
  for (let i = 0; i < contour.data32S.length; i += 2) {
    let x = contour.data32S[i];
    let y = contour.data32S[i + 1];
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.fill();
}

// 清理资源
window.addEventListener('beforeunload', () => {
  if (processingInterval) clearInterval(processingInterval);
  if (src) src.delete();
  if (gray) gray.delete();
  if (edges) edges.delete();
  if (blurred) blurred.delete();
  if (thresh) thresh.delete();
});

// 页面加载时初始化
loadOpenCV().catch(e => {
  statusDiv.textContent = 'OpenCV 加载失败: ' + e.message;
  alert('OpenCV 加载失败，请刷新页面重试');
});
</script>
</body>
</html>
